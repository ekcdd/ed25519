/*
* sodiumtest.c
 *
 * Ed25519 Compatibility and Interoperability Test Suite
 *
 * Description:
 *   This test suite validates interoperability between the orlp Ed25519 implementation
 *   and the libsodium Ed25519 implementation. It ensures that:
 *
 *     - Keypairs generated by each library are internally consistent.
 *     - Cross-library signature verification works correctly
 *       (orlp signing verified by libsodium, and vice versa).
 *     - Keypairs generated from the same seed are deterministic.
 *     - Keys in different formats (libsodium vs. orlp) are compatible and
 *       conversions preserve signing ability.
 *     - Signatures are correct, including edge cases like empty messages
 *       or intentionally invalid signatures.
 *     - Wrapper functions produce signatures identical to native libsodium.
 *
 *   Each test prints detailed results, and the suite returns a non-zero exit code
 *   if any test fails.
 *
 * Usage:
 *   Compile with:
 *       gcc -o sodiumtest sodiumtest.c ed25519.c -lsodium
 *   Run:
 *       ./sodiumtest
 *
 * Notes:
 *   - Requires libsodium to be installed and initialized.
 *   - Designed for developers verifying the correctness of Ed25519 implementations
 *     and cross-library compatibility.
 */

#include <stdio.h>
#include <string.h>
#include <sodium.h>

#include <ed25519/compat.h>
#include <ed25519/ed25519.h>




#define TEST_PASSED printf("Passed: %s\n", __func__)
#define TEST_FAILED printf("Failed: %s\n", __func__)

#define ASSERT(condition, msg) \
    do { \
        if (!(condition)) { \
            printf("  ASSERTION FAILED: %s\n", msg); \
            TEST_FAILED; \
            return 0; \
        } \
    } while(0)

int test_count = 0;
int test_passed = 0;

/* Test 1: orlp keypair can verify signatures from orlp */
int test_orlp_self_compatibility() {
    test_count++;
    unsigned char seed[32];
    unsigned char pk[32], sk[64];
    const unsigned char message[] = "test message";
    unsigned char sig[64];

    ASSERT(ed25519_create_seed(seed) == 0, "seed creation");
    ed25519_create_keypair(pk, sk, seed);
    ed25519_sign(sig, message, sizeof(message) - 1, pk, sk);

    ASSERT(ed25519_verify(sig, message, sizeof(message) - 1, pk) == 1,
           "signature verification");

    TEST_PASSED;
    test_passed++;
    return 1;
}

/* Test 2: libsodium keypair can verify signatures from libsodium */
int test_libsodium_self_compatibility() {
    test_count++;
    unsigned char seed[crypto_sign_SEEDBYTES];
    unsigned char pk[crypto_sign_PUBLICKEYBYTES];
    unsigned char sk[crypto_sign_SECRETKEYBYTES];
    const unsigned char message[] = "test message";
    unsigned char sig[crypto_sign_BYTES];
    unsigned long long sig_len = 0;

    /* Generate random seed */
    randombytes(seed, sizeof(seed));

    ASSERT(crypto_sign_seed_keypair(pk, sk, seed) == 0, "seed keypair creation");
    ASSERT(crypto_sign_detached(sig, &sig_len, message, sizeof(message) - 1, sk) == 0,
           "signature creation");
    ASSERT(crypto_sign_verify_detached(sig, message, sizeof(message) - 1, pk) == 0,
           "signature verification");

    TEST_PASSED;
    test_passed++;
    return 1;
}

/* Test 3: Cross-library signature verification (orlp signed, libsodium verifies) */
int test_orlp_sign_libsodium_verify() {
    test_count++;
    unsigned char seed[32];
    unsigned char orlp_pk[32], orlp_sk[64];
    const unsigned char message[] = "cross library test";
    unsigned char orlp_sig[64];

    ASSERT(ed25519_create_seed(seed) == 0, "seed creation");
    ed25519_create_keypair(orlp_pk, orlp_sk, seed);
    ed25519_sign(orlp_sig, message, sizeof(message) - 1, orlp_pk, orlp_sk);

    /* libsodium verify expects 64 byte signatures */
    ASSERT(crypto_sign_verify_detached(orlp_sig, message, sizeof(message) - 1, orlp_pk) == 0,
           "libsodium can verify orlp signature");

    TEST_PASSED;
    test_passed++;
    return 1;
}

/* Test 4: Cross-library signature verification (libsodium signed, orlp verifies) */
int test_libsodium_sign_orlp_verify() {
    test_count++;
    unsigned char seed[crypto_sign_SEEDBYTES];
    unsigned char pk[crypto_sign_PUBLICKEYBYTES];
    unsigned char sk[crypto_sign_SECRETKEYBYTES];
    const unsigned char message[] = "cross library test";
    unsigned char sig[crypto_sign_BYTES];
    unsigned long long sig_len = 0;

    /* Generate random seed */
    randombytes(seed, sizeof(seed));

    ASSERT(crypto_sign_seed_keypair(pk, sk, seed) == 0, "keypair creation");
    ASSERT(crypto_sign_detached(sig, &sig_len, message, sizeof(message) - 1, sk) == 0,
           "signature creation");

    /* orlp verify with libsodium public key */
    ASSERT(ed25519_verify(sig, message, sizeof(message) - 1, pk) == 1,
           "orlp can verify libsodium signature");

    TEST_PASSED;
    test_passed++;
    return 1;
}

/* Test 5: Key format compatibility - libsodium format structure */
int test_libsodium_key_format() {
    test_count++;
    unsigned char seed[crypto_sign_SEEDBYTES];
    unsigned char pk[crypto_sign_PUBLICKEYBYTES];
    unsigned char sk[crypto_sign_SECRETKEYBYTES];

    /* Generate with known seed */
    memset(seed, 0x42, crypto_sign_SEEDBYTES);
    ASSERT(crypto_sign_seed_keypair(pk, sk, seed) == 0, "keypair from seed");

    /* Verify libsodium format: first 32 bytes are seed, last 32 are public key */
    ASSERT(memcmp(sk, seed, crypto_sign_SEEDBYTES) == 0, "first 32 bytes of sk match seed");
    ASSERT(memcmp(sk + crypto_sign_SEEDBYTES, pk, crypto_sign_PUBLICKEYBYTES) == 0, "last 32 bytes of sk match public key");

    TEST_PASSED;
    test_passed++;
    return 1;
}

/* Test 6: Different messages produce different signatures */
int test_different_messages() {
    test_count++;
    unsigned char seed[32];
    unsigned char pk[32], sk[64];
    const unsigned char msg1[] = "message one";
    const unsigned char msg2[] = "message two";
    unsigned char sig1[64], sig2[64];

    ed25519_create_seed(seed);
    ed25519_create_keypair(pk, sk, seed);
    ed25519_sign(sig1, msg1, sizeof(msg1) - 1, pk, sk);
    ed25519_sign(sig2, msg2, sizeof(msg2) - 1, pk, sk);

    ASSERT(memcmp(sig1, sig2, 64) != 0, "different messages have different signatures");

    /* But each should verify with correct message */
    ASSERT(ed25519_verify(sig1, msg1, sizeof(msg1) - 1, pk) == 1, "sig1 verifies msg1");
    ASSERT(ed25519_verify(sig2, msg2, sizeof(msg2) - 1, pk) == 1, "sig2 verifies msg2");
    ASSERT(ed25519_verify(sig1, msg2, sizeof(msg2) - 1, pk) == 0, "sig1 fails for msg2");
    ASSERT(ed25519_verify(sig2, msg1, sizeof(msg1) - 1, pk) == 0, "sig2 fails for msg1");

    TEST_PASSED;
    test_passed++;
    return 1;
}

/* Test 7: Same seed produces same keypair */
int test_deterministic_keypair() {
    test_count++;
    unsigned char seed[32];
    unsigned char pk1[32], sk1[64];
    unsigned char pk2[32], sk2[64];

    /* Use fixed seed for reproducibility */
    memset(seed, 0x55, 32);

    ed25519_create_keypair(pk1, sk1, seed);
    ed25519_create_keypair(pk2, sk2, seed);

    ASSERT(memcmp(pk1, pk2, 32) == 0, "same seed produces same public key");
    ASSERT(memcmp(sk1, sk2, 64) == 0, "same seed produces same private key");

    TEST_PASSED;
    test_passed++;
    return 1;
}

/* Test 8: Invalid signature detection */
int test_invalid_signature_detection() {
    test_count++;
    unsigned char seed[32];
    unsigned char pk[32], sk[64];
    const unsigned char message[] = "test";
    unsigned char sig[64];

    ed25519_create_seed(seed);
    ed25519_create_keypair(pk, sk, seed);
    ed25519_sign(sig, message, sizeof(message) - 1, pk, sk);

    /* Flip a bit in signature */
    sig[0] ^= 0x01;

    ASSERT(ed25519_verify(sig, message, sizeof(message) - 1, pk) == 0,
           "modified signature fails verification");

    TEST_PASSED;
    test_passed++;
    return 1;
}

/* Test 9: Size constants match */
int test_size_constants() {
    test_count++;

    ASSERT(crypto_sign_PUBLICKEYBYTES == 32, "libsodium public key is 32 bytes");
    ASSERT(crypto_sign_SECRETKEYBYTES == 64, "libsodium secret key is 64 bytes");
    ASSERT(crypto_sign_BYTES == 64, "libsodium signature is 64 bytes");

    TEST_PASSED;
    test_passed++;
    return 1;
}

/* Test 10: Empty message handling */
int test_empty_message() {
    test_count++;
    unsigned char seed[32];
    unsigned char pk[32], sk[64];
    unsigned char sig[64];
    const unsigned char empty_msg[] = "";

    ed25519_create_seed(seed);
    ed25519_create_keypair(pk, sk, seed);
    ed25519_sign(sig, empty_msg, 0, pk, sk);

    ASSERT(ed25519_verify(sig, empty_msg, 0, pk) == 1,
           "empty message signature verifies");

    TEST_PASSED;
    test_passed++;
    return 1;
}

/* Test 11: Compatibility wrapper - create keypair in libsodium format */
int test_compat_create_keypair_libsodium() {
    test_count++;
    unsigned char libsodium_pk[32];
    unsigned char libsodium_sk[64];
    const unsigned char message[] = "test message";
    unsigned char sig[64];

    ASSERT(ed25519_create_keypair_libsodium(libsodium_pk, libsodium_sk) == 0,
           "create keypair in libsodium format");

    /* Sign using compatibility wrapper */
    ASSERT(ed25519_sign_libsodium(sig, message, sizeof(message) - 1, libsodium_sk) == 0,
           "sign with libsodium format key");

    /* Verify using compatibility wrapper */
    ASSERT(ed25519_verify_libsodium(sig, message, sizeof(message) - 1, libsodium_pk) == 1,
           "verify signature with libsodium format");

    TEST_PASSED;
    test_passed++;
    return 1;
}

/* Test 12: Compatibility wrapper - libsodium format key structure */
int test_compat_libsodium_format() {
    test_count++;
    unsigned char libsodium_pk[32];
    unsigned char libsodium_sk[64];

    ed25519_create_keypair_libsodium(libsodium_pk, libsodium_sk);

    /* Verify structure: first 32 bytes are seed, last 32 are public key */
    ASSERT(memcmp(libsodium_sk + 32, libsodium_pk, 32) == 0,
           "libsodium_sk[32:64] matches public key");

    TEST_PASSED;
    test_passed++;
    return 1;
}

/* Test 13: Cross-compatibility - orlp library signs, libsodium format verifies */
int test_compat_orlp_sign_libsodium_verify() {
    test_count++;
    unsigned char seed[32];
    unsigned char orlp_pk[32], orlp_sk[64];
    const unsigned char message[] = "compat test";
    unsigned char sig[64];

    /* Create with orlp */
    ed25519_create_seed(seed);
    ed25519_create_keypair(orlp_pk, orlp_sk, seed);
    ed25519_sign(sig, message, sizeof(message) - 1, orlp_pk, orlp_sk);

    /* Verify with compatibility wrapper (which uses orlp underneath) */
    ASSERT(ed25519_verify_libsodium(sig, message, sizeof(message) - 1, orlp_pk) == 1,
           "compatibility wrapper can verify orlp signatures");

    TEST_PASSED;
    test_passed++;
    return 1;
}

int test_same_seed_same_public_key() {
    test_count++;
    unsigned char seed[32];
    unsigned char orlp_pk[32], orlp_sk[64];
    unsigned char sodium_pk[crypto_sign_PUBLICKEYBYTES];
    unsigned char sodium_sk[crypto_sign_SECRETKEYBYTES];

    for (int i = 0; i < 32; i++) seed[i] = (unsigned char)(i + 1);

    ed25519_create_keypair(orlp_pk, orlp_sk, seed);
    ASSERT(crypto_sign_seed_keypair(sodium_pk, sodium_sk, seed) == 0, "libsodium keypair");

    ASSERT(memcmp(orlp_pk, sodium_pk, 32) == 0, "orlp pk == libsodium pk for same seed");

    TEST_PASSED; test_passed++; return 1;
}

int test_same_key_same_message_same_signature() {
    test_count++;
    unsigned char seed[32];
    unsigned char orlp_pk[32], orlp_sk[64];
    unsigned char sodium_pk[32], sodium_sk[64];
    const unsigned char msg[] = "deterministic sig";
    unsigned char sig_orlp[64];
    unsigned char sig_sodium[64];
    unsigned long long siglen = 0;

    for (int i = 0; i < 32; i++) seed[i] = (unsigned char)(0xA0 + i);

    ed25519_create_keypair(orlp_pk, orlp_sk, seed);
    ASSERT(crypto_sign_seed_keypair(sodium_pk, sodium_sk, seed) == 0, "libsodium keypair");
    ASSERT(memcmp(orlp_pk, sodium_pk, 32) == 0, "pk equal");

    ed25519_sign(sig_orlp, msg, sizeof(msg) - 1, orlp_pk, orlp_sk);
    ASSERT(crypto_sign_detached(sig_sodium, &siglen, msg, sizeof(msg) - 1, sodium_sk) == 0, "libsodium sign");
    ASSERT(siglen == 64, "signature length 64");

    ASSERT(memcmp(sig_orlp, sig_sodium, 64) == 0, "orlp and libsodium signatures are identical");

    TEST_PASSED; test_passed++; return 1;
}

int test_wrapper_signature_matches_libsodium() {
    test_count++;
    unsigned char seed[32];
    unsigned char pk[32], sk[64];
    const unsigned char msg[] = "compat sig equality";
    unsigned char sig_wrapper[64];
    unsigned char sig_sodium[64];
    unsigned long long siglen = 0;

    for (int i = 0; i < 32; i++) seed[i] = (unsigned char)(0x11 * i);

    ASSERT(crypto_sign_seed_keypair(pk, sk, seed) == 0, "libsodium keypair");
    ASSERT(ed25519_sign_libsodium(sig_wrapper, msg, sizeof(msg) - 1, sk) == 0, "wrapper sign");
    ASSERT(crypto_sign_detached(sig_sodium, &siglen, msg, sizeof(msg) - 1, sk) == 0, "libsodium sign");
    ASSERT(siglen == 64, "signature length 64");

    ASSERT(memcmp(sig_wrapper, sig_sodium, 64) == 0, "wrapper signature matches libsodium exactly");

    TEST_PASSED; test_passed++; return 1;
}

int test_convert_libsodium_sk_to_orlp_and_sign() {
    test_count++;
    unsigned char seed[32];
    unsigned char pk[32], sk[64];
    const unsigned char msg[] = "convert test";
    unsigned char sig_orlp_from_conv[64];
    unsigned char sig_sodium[64];
    unsigned long long siglen = 0;
    unsigned char orlp_sk[64];

    for (int i = 0; i < 32; i++) seed[i] = (unsigned char)(0x55 + i);

    ASSERT(crypto_sign_seed_keypair(pk, sk, seed) == 0, "libsodium keypair");
    ASSERT(ed25519_libsodium_to_orlp_secret_key(orlp_sk, sk) == 0, "convert libsodium->orlp sk");

    ed25519_sign(sig_orlp_from_conv, msg, sizeof(msg) - 1, pk, orlp_sk);
    ASSERT(crypto_sign_detached(sig_sodium, &siglen, msg, sizeof(msg) - 1, sk) == 0, "libsodium sign");

    ASSERT(memcmp(sig_orlp_from_conv, sig_sodium, 64) == 0, "signatures equal after conversion");

    TEST_PASSED; test_passed++; return 1;
}

int main() {
    if (sodium_init() < 0) {
        printf("Failed to initialize libsodium\n");
        return 1;
    }

    printf("=== Ed25519 libsodium Compatibility Test Suite ===\n\n");

    test_orlp_self_compatibility();
    test_libsodium_self_compatibility();
    test_orlp_sign_libsodium_verify();
    test_libsodium_sign_orlp_verify();
    test_libsodium_key_format();
    test_different_messages();
    test_deterministic_keypair();
    test_invalid_signature_detection();
    test_size_constants();
    test_empty_message();
    test_compat_create_keypair_libsodium();
    test_compat_libsodium_format();
    test_compat_orlp_sign_libsodium_verify();

    /* New equality/identity checks against libsodium */
    test_same_seed_same_public_key();
    test_same_key_same_message_same_signature();
    test_wrapper_signature_matches_libsodium();
    test_convert_libsodium_sk_to_orlp_and_sign();

    printf("\n=== Results ===\n");
    printf("Passed: %d/%d\n", test_passed, test_count);


    return (test_passed == test_count) ? 0 : 1;
}